<script type="text/javascript">
    RED.nodes.registerType('hal2Group',{
        category: 'Home Automation',
        color: '#b3b3ff',
        defaults: {
            eventHandler: {
                value: "Event handler",
                type: "hal2EventHandler",
                required: true
            },
            name: {
                    required: true, 
                    validate:function(v) {
                        //Check for name collisions
                        const itemsList = RED.nodes.filterNodes({type: "hal2Group"});
                        if(itemsList.length===0){ return true; }
                        for (var d in itemsList) {
                            if (v == itemsList[d].name && itemsList[d].id !== this.id) { return false; }
                        }
                        return true;
                    }
                  },
            group:          {},
            ratelimit:      { value: 0},
            output:         { value:false },
            input:          { value:false },
            outputs:        { value: 0 }, //Storing if outputs are enabled.
            inputs:         { value: 0 } //Storing if inputs are enabled.
        },
        inputs:0,
        outputs:0,
        icon: "group.png",
        label: function() {
            return this.name||"group";
        },
        paletteLabel: "group",
        oneditprepare: function () {
            //get all thing nodes and sort them alphabetically
            const thingsList = RED.nodes.filterNodes({type: "hal2Thing"});
            thingsList.sort(function(a, b) {
                var textA = a.name.toUpperCase();
                var textB = b.name.toUpperCase();
                return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;
            });           

            //No thing nodes have been created
            if(thingsList.length===0){
                $("<li>No things found</li>").appendTo("#node-input-group-container");
                return;
            }

            $("#node-input-group-container").editableList({
                addItem: function(container,i,opt) {
                    var group = opt;
                    var savedThing = group.thing;
                    var savedItem = group.item;

                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });

                    //Add rows
                    var rowThing = $('<div/>').appendTo(container);
                    var rowItem = $('<div/>',{style:"margin-top:8px;"}).appendTo(container);

                    //Add labels
                    var label1 = $('<div/>',{style:"display:inline-block;text-align:left; width:60px; padding-right:10px; box-sizing:border-box;",class:"fa fa-microchip"})
                        .appendTo(rowThing);
                    label1.append(' Thing');
                    var label2 = $('<div/>',{style:"display:inline-block;text-align:left; width:60px; padding-right:10px; box-sizing:border-box;",class:"fa fa-sitemap"})
                        .appendTo(rowItem);
                    label2.append(' Item');

                    var thingsField = $('<select/>',{class:"node-input-group-thing",style:"width:calc(100% - 70px)"}).appendTo(rowThing);
                    var itemsField = $('<select/>',{class:"node-input-group-item",style:"width:calc(100% - 70px)"}).appendTo(rowItem);

                    thingsField.change(function() {
                        let thing = RED.nodes.node(thingsField.val());
                        itemsField.children().remove();

                        if (thing.type == "hal2Thing") {    
                            rowItem.show();                      
                            //get all items and sort them alphabetically
                            let thing = RED.nodes.node(thingsField.val());
                            let thingType = RED.nodes.node(thing.thingType);
                            //Add items                            
                            for (let d in thingType.items) {
                                itemsField.append($("<option></option>").val(thingType.items[d].id).text(thingType.items[d].name));
                            }
                            if ((savedItem != null) & (thingsField.val() == savedThing)) {
                                itemsField.val(savedItem);
                            }
                        } else {
                            rowItem.hide();
                            itemsField.append($("<option></option>")
                                .val(thing.id)
                                .text(thing.name));
                        }                            
                    });
           
                    //Add things
                    for (let d in thingsList) {
                        thingsField.append($("<option></option>").val(thingsList[d].id).text(thingsList[d].name));
                    }

                    //Add values
                    if (Object.keys(group).length != 0) {
                        thingsField.val(group.thing);
                    }
                    thingsField.trigger('change');
                },
                removable: true,
                sortable: true,
                addButton: "Item"
            });

            //Add group members
            if (this.group) {
                for (var i=0; i<this.group.length; i++) {
                    var group = this.group[i];
                    $("#node-input-group-container").editableList('addItem',group);
                }
            } else {
                $("#node-input-group-container").editableList('addItem',null);              
            }
        },
        oneditsave: function() {
            var groupcontainer = $("#node-input-group-container").children();
            var node = this;
            node.group = [];

            groupcontainer.each(function(i) {
                var group = $(this);
                var b = {
                    thing:group.find(".node-input-group-thing option:selected").val(),
                    item:group.find(".node-input-group-item option:selected").val(),
                }
                debugger
                node.group.push(b);
            });

            if ($("#node-input-output").is(":checked")) {
                node.outputs = 1;
            } else {
                node.outputs = 0;
            }
            if ($("#node-input-input").is(":checked")) {
                node.inputs = 1;
            } else {
                node.inputs = 0;
            }
        }
    });
</script>

<script type="text/x-red" data-template-name="hal2Group">
    <div class="form-row">
        <label for="node-input-eventHandler"><i class="fa fa-ellipsis-h"></i> Event handler</label>
        <input type="text" id="node-input-eventHandler" style="width:70%" placeholder="Event handler">
    </div>
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name" style="width:70%">
    </div>
    <div class="form-row">
            <ol id="node-input-group-container"</ol>
    </div>
    <div class="form-row">
        <i class="fa fa-pause-circle-o"></i> Wait <input type="number" value="0" id="node-input-ratelimit" style="display: inline-block; width: 70px; vertical-align: middle;"> ms between group members when sending messages.
    </div>
    <div class="form-row">
        <label for="node-input-input"><i class="fa fa-sign-in"></i> Use input</label>
        <input type="checkbox" id="node-input-input" style="display: inline-block; width: auto; vertical-align: top;">
    </div>
    <div class="form-row">
        <label for="node-input-output"><i class="fa fa-sign-out"></i> Use output</label>
        <input type="checkbox" id="node-input-output" style="display: inline-block; width: auto; vertical-align: top;">
    </div>
</script>

<script type="text/x-red" data-help-name="hal2Group">
    <p>The Bundle node allows you to group multiple <i>Items</i> together and send their values on, one after another, when triggered.</p>
    <li><strong>Name</strong>: Node name.</li> 
    <li><strong>Output</strong>: Select what value the node should be sending on to the next node when triggered. If <i>thing state</i> is selected, the property configured in the <i>Item</i> node as the <i>state</i> property is sent. The configured <code>msg.name</code> and <code>msg.topic</code> from the <i>Item</i> is always added to the outgoing <code>msg</code>.</li>
    <li><string>Wait between messages</strong> allows you to rate limit the output.</li>
</script>